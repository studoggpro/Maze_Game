package com.stukeenan.gametest2.model;

import javafx.scene.Node;

import java.util.*;

public class CreatePath {
    private static int[][] mazeArray = new int[Room.mazeLength][4];
    private static int pathLength = 2;
    private static int startDoor;
    public static Map<Node, Node> mazeMap = new HashMap<>(64);
    private static Node currentKey;
    public static Node exitDoor;
    private static Node key;
    private static Node value;
    private static Random rand = new Random();
    private static String room;


    public static void createPath(){
        shuffleDoors();
        createMazeMap();
        assignRemainingDoors(Door.topDoorList, Door.bottomDoorList);
        assignRemainingDoors(Door.rightDoorList, Door.leftDoorList);
    }


    public static void shuffleDoors(){
        Collections.shuffle(Door.bottomDoorList);
        Collections.shuffle(Door.leftDoorList);
        Collections.shuffle(Door.rightDoorList);
        Collections.shuffle(Door.topDoorList);
    }

    private static Map<Node, Node> createMazeMap(){
        for (int i = 0; i <= pathLength; i++) {
            if (i == 0){
                room = "room0";
                setStartDoor();
                key();
                currentKey = key;
                value = value();
            }
            if (i > 0 && i < pathLength){
                room = value.getParent().getId();
                setStartDoor();
                key();
                currentKey = key;
                value = value();
            }
            if (i == pathLength){
                room = value.getParent().getId();
                setStartDoor();
                key();
                exitDoor = key;
                break;
            }
            mazeMap.put(currentKey, value);
        }

        return mazeMap;
    }

    private static void key(){
        int y = 0;
        LinkedList<Node> list = new LinkedList<>();
        key = null;
        switch (startDoor){
            case 0: list = Door.topDoorList;
                lookAhead(list);
                y = 0;
                break;
            case 1: list = Door.rightDoorList;
                lookAhead(list);
                y = 1;
                break;
            case 2: list = Door.bottomDoorList;
                lookAhead(list);
                y = 2;
                break;
            case 3: list = Door.leftDoorList;
                lookAhead(list);
                y = 3;
                break;
            default: if (!list.isEmpty()){
                list.clear();
            }
                break;
        }
            for (Node node : list) {
                if (node.getId().contains(room)) {
                    key = node;
                    break;
                }
            }
            if (key == null) {
                resetStartDoor();
            }
            fillMazeArray(room, y);
            list.remove(key);
    }

    private static Node value(){
        int y = 0;
        if (currentKey.getId().contains(String.valueOf(Location.TOP))){
            checkForClosedRooms(Door.bottomDoorList);
            value = Door.bottomDoorList.poll();
            y = 2;
        }
        if (currentKey.getId().contains(String.valueOf(Location.RIGHT))){
            checkForClosedRooms(Door.leftDoorList);
            value = Door.leftDoorList.poll();
            y = 3;
        }
        if (currentKey.getId().contains(String.valueOf(Location.BOTTOM))){
            checkForClosedRooms(Door.topDoorList);
            value = Door.topDoorList.poll();
            y = 0;
        }
        if (currentKey.getId().contains(String.valueOf(Location.LEFT))){
            checkForClosedRooms(Door.rightDoorList);
            value = Door.rightDoorList.poll();
            y = 1;
        }
        fillMazeArray(value.getParent().getId(), y);
        return value;
    }

    /**mazeArray x = room#
     * y=Door:
     * Top Door = 0
     * Right Door = 1
     * Bottom Door = 2
     * Left Door = 3**/

    private static int[][] fillMazeArray(String room, int y){
        int x = Integer.parseInt((room.split("m"))[1]);
        if (mazeArray[x][y] == 1){
            System.out.println("there is a problem!!!");
            System.out.println("x: " + x + " y: " + y);
        } else {
            mazeArray[x][y] = 1;
        }
        return mazeArray;
    }

    private static void checkForClosedRooms(LinkedList<Node> doorList){
        Node testNode = doorList.peek();
        int x = Integer.parseInt((testNode.getParent().getId().split("m"))[1]);
        Long doorCount = Arrays.stream(mazeArray[x]).filter(i -> i == 1).count();
        if (doorCount >= 3){
            doorList.offerLast(doorList.poll());
            /*Node newRoom = doorList.peek();
            if (newRoom == room){
                checkForClosedRooms(newRoom, doorList);
            }*/
        }
    }

    private static void lookAhead(LinkedList<Node> doorList){
        int currentRoom = Integer.parseInt((room.split("m"))[1]);
        Long doorCount = Arrays.stream(mazeArray[currentRoom]).filter(i -> i == 1).count();
        if (doorList.size() == 1 && doorCount == 3){
            resetStartDoor();
        }

    }

    private static void assignRemainingDoors(LinkedList<Node> keyList, LinkedList<Node> valueList){
        Node remainingKey;
        Node remainingValue;
        int maxSize = Math.max(keyList.size(), valueList.size());
        for (int i = 0; i < maxSize; i++) {
            if (keyList.isEmpty()){
                remainingKey = null;
            } else {
                remainingKey = keyList.poll();
            }
            if (valueList.isEmpty()){
                remainingValue = null;
            } else {
                remainingValue = valueList.poll();
            }
            mazeMap.put(remainingKey, remainingValue);
        }
    }

    private static void setStartDoor(){
        startDoor = rand.nextInt(4);
    }

    private static void resetStartDoor  (){
        if (startDoor >= 0) {
            startDoor ++;
        }
        if (startDoor > 3){
            startDoor = 0;
        }
        key();
    }
}
